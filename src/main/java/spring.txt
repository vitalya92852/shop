Spring - фреймворк предназначенный для создания крупных корпоративных
приложений на Java в основе которого лежат модули Java EE/Jakarta EE. Spring
является абстракцией над модулями Java EE/Jakarta EE упрощая работу с ними.

Spring может примениться для разработки любых приложений (консольные, с оконным
интерфейсом, web, ...), но в основном применяется для разработки веб-приложений
за счет удобного модуля Spring MVC.

Современные веб приложения работают по протоколу HTTP.

HTTP - транспортный протокол реализующий модель взаимодействия клиент-сервер
между сторонами обмена информацией. Клиент-серверная модель взаимодействия
подразумевает формирование клиентом запроса к серверу и сформированный ответ
сервера клиенту.

Клиент - сторона формирующая запрос к одному из ресурсов сервера. В качестве
клиента зачастую выступает браузер, но одним браузером дело не ограничивается,
в качестве клиента может выступать мобильное приложение либо другое веб
приложение и так далее.

Сервер - сторона принимающая входящий запрос клиента и отправляющая его на
дальше на обработку, после обработки запроса сервер должен сформировать ответ и
отправить его обратно клиенту.

Клиент -> Запрос -> Сервер -> Ответ -> Клиент

Ресурс - адрес запрашиваемый клиентом на сервере.

`https://vk.com` - запрос ресурса `/` на сервере `vk.com`.

`https://vk.com/messages` - запрос ресурса `/messages` на сервере `vk.com`.

`https://youtube.com/watch?id=133578` - запрос ресурса `/watch` с параметром
`id` и значением `133578` на сервере `youtube.com`.

Ответ сервера всегда должен состоять из: статус, заголовки, тело ответа.

Возможные статусы ответа сервера:
* `2xx` - группа статусов говорящая об успешном выполнении запроса.
* `3xx` - группа статусов говорящая об успешном выполнении запроса с
перенаправлением на другой ресурс.
* `4xx` - группа статусов говорящая об ошибке при выполнении запроса по вине
клиента.
* `5xx` - группа статусов говорящая об ошибке при выполнении запроса по вине
сервера.

Заголовок `Content-Type` определяет тип содержимого которое будет возвращено в
теле ответа.
Возможные значения для заголовка `Content-Type`:
* `text/plain` - обычный текст.
* `text/html` - текст формата HTML.
* `application/json` - текст формата JSON.
* `application/pdf` - документ формата PDF.
* `image/jpeg` - изображение формата JPEG.
* `image/png` - изображение формата PNG.

JSON - специальный язык для обмена сообщениями между разными сервисами.

Пакет Spring Web предоставляет инструменты для разработки веб приложений по
паттерну MVC.
Компоненты паттерна MVC:
1) M (модель) - слой работы с данными.
2) V (представление) - слой отображения информации (HTML, JSON и так далее).
3) C (контроллер) - связующий слой между моделью и представлением через который
будет идти приемка запросов и формирование ответов.

Клиент -> Контроллер -> Модель -> Контроллер -> Представление -> Клиент

Контроллер - класс помеченный аннотаций @Controller/@RestController каждый
метод которого должен отвечать за обработку одного отдельно взятого ресурса веб
приложения.

Один метод контроллера = один ресурс веб приложения.

`https://vk.com` -> `/` -> `MainController.mainPage`
`https://vk.com/messages` -> `/messages` -> `MessageController.messageListPage`
`https://vk.com/profile/alex` -> `/profile/alex` -> `ProfileController.profilePage`
`https://vk.com/profile/mark` -> `/profile/mark` -> `ProfileController.profilePage`

`@Controller/@RestController` - регистрирует класс в контексте Spring как
контроллер.

`@Controller` - подразумевает что результатом работы ресурсов будет содержимое
формата HTML.

`@RestController` - подразумевает что результатом работы ресурсов будет
записываться напрямую в тело ответа с возможностью регулировки типа содержимого
(по умолчанию JSON).

`@ResponseBody` - если применяется эта аннотация к методу контроллера, то его
результат будет записан напрямую в тело ответа без попыток сопоставить
результат с HTML документом. По умолчанию все методы при использовании
аннотации @RestController будут помечены как @ResponseBody.

Один и тот же ресурс можно запрашивать различными методами запроса.
Основные методы HTTP запросов:
1) GET - метод, который передает данные напрямую в адресе запрашиваемого
ресурса, что делает его небезопасным для передачи важной информации. При
запросе ресурса напрямую из адресной строки браузера будет использован метод
GET.
2) POST - метод, который передает данные в теле запроса (часть запроса скрытая
от глаз). При использовании метода POST можно передавать файлы. Тело запроса
дополнительно шифруется при наличии SSL сертификата на запрашиваемом сервере.

`@RequestMapping` - применяется к классу контроллера и его методам для
определения пути по которому будет идти обращение к ресурсу. @RequestMapping
позволяет делать обращение к ресурсу любым методом запроса.

`@GetMapping` - вариация @RequestMapping исключительно для GET метода.

`@PostMapping` - вариация @RequestMapping исключительно для POST метода.

У двух ресурсов может быть один и тот же адрес, но разные метода запросов.
`http://localhost:8080/create_product` -> GET -> ресурс #1.
`http://localhost:8080/create_product` -> POST -> ресурс #2.

Передача параметров в адресной строке запрашиваемого ресурса начинается с
вопросительного знака. Параметры записываются в формате ключ=значение как в
структуре данных словарь. Если передаются несколько параметров, то они
разделяются через амперсанд.

`http://localhost:8080/some_resource` - запрос ресурса some_resource без
передачи параметров.

`http://localhost:8080/some_resource?name=Марк` - запрос ресурса some_resource
с параметром name значение которого Марк.

`http://localhost:8080/some_resource?name=Марк&age=34` - запрос ресурса
some_resource с параметрами name и age значение которых Марк и 34
соответственно.

В обычной ситуации разработчик полностью управляет созданием объектов и
построением взаимосвязей между ними.

Инверсия управления - принцип согласно которому ответственность за создание
объектов и построение взаимосвязей между ними перекладывается на фреймворк.

IOC контейнер - отдельная программа управляющая жизненным циклом объектов
приложения согласно описанному ранее принципу.

Внедрение зависимостей - паттерн согласно которому должна быть возможность
внедрения одного объекта в другой с целью использования его возможностей.

Bean - обычный Java класс за жизненный цикл которого отвечает Spring IOC
контейнер.

Java класс -> Конфигурация -> Spring Bean.

На этапе конфигурации описывается логика создания объекта того класса из
которого необходимо сформировать Spring Bean. Мы лишь описывается процесс
создания объекта, но в какой момент времени будет объект решает Spring IOC
контейнер.

Объект Spring Bean можно внедрять в любой другой объект Spring Bean, но при
этом внедрение нельзя делать в обычные в обычные классы.

Аннотации применение которых к классу делает его Spring Bean:
`@Component` - общая аннотация без определенного контекста.
- `@Controller` - аннотация для контекста контроллеров. При использовании
данной аннотации Spring будет дополнительно проверять @*Mapping аннотации.
- `@Repository` - аннотация для контекста работы с данными.
- `@Service` - аннотация для сервисного слоя приложения.

По умолчанию каждый Spring Bean создается как singleton, то есть один экземпляр
на весь жизненный цикл приложения.

Шаблонизатор - отдельная библиотека предназначенная для динамического
построения HTML структуры основываясь на данных полученных с контроллера.

Spring по умолчанию конфигурирует шаблонизатор таким образом, чтобы он искал
HTML документы в папке templates, а статичные ресурсы (CSS, JavaScript,
изображения и так далее) в папке static.

Thymeleaf - библиотека шаблонизатор работающая на основе кастомных аттрибутов
которые должны быть вынесены в отдельное пространство имен (может быть любым,
но по умолчанию рекомендуется использовать th).

Для того чтобы добавить это пространство имен с дополнительными аттрибутами
необходимо в тэг <html> добавить следующий аттрибут:
* `xmlns:th="http://www.thymeleaf.org"`

`Model` - объект выступающий в роли связующего звена между контроллером и
представлением. Для передачи информации из контроллера в представление её
сначала необходимо добавить в объект Model в качестве аттрибута.

Java веб-приложение всегда работает относительно контекста сервера.

http://localhost:8080 (context: /)
/css/style.css
`href="/css/style.css"` -> /css/style.css
`th:href="@{/css/style.css}"` -> /css/style.css

http://localhost:8080/shop (context: /shop)
/shop/css/style.css
`href="/css/style.css"` -> /css/style.css
`th:href="@{/css/style.css}"` -> /shop/css/style.css

Spring Data JPA - модуль фреймворка Spring предназначенный для работы с базами
данных основываясь на стандарте JPA. В качестве реализации стандарта JPA Spring
Data использует Hibernate. Spring Data JPA предоставляет дополнительную
абстракцию для работы с данными в виде репозиториев.

Репозиторий - объект выступающий в качестве своеобразной абстракции над
объектом EntityManager, репозиторий может использоваться для проведения всех
базовых операций над сущностью определенного типа (выборка, создание, изменение
и удаление). Под каждый тип сущности должен создаваться отдельный репозиторий.

Spring Data JPA будет создавать реализации интерфейсов репозиториев на этапе
компиляции без вмешательства разработчика.

Spring репозитории содержут следующие стандартные методы:

`ID` - тип данных первичного ключа определенный при создании репозитория.
`T` - тип сущности определенный при создании репозитория.

`*.findById(ID id) : Optional<T>` - возвращает найденную сущность обернутую в
объект Optional по первичного ключу из параметра `id` либо пустой объект
Optional если сущность не была найдена.

`*.findAll() : List<T>` - возвращает список содержащий в себе все сущности
полученные из таблицы базы данных.

`@AllArgsConstructor` - создаёт конструктор в которым через параметры будут
приниматься значения для всех полей класса (кроме статичных).

`@RequiredArgsConstructor` - создаёт конструктор в которым через параметры
будут приниматься значения для обязательных полей класса (не статичные поля
помеченные ключевым словом final).

`Sort` - объект предназначенный для определения правил сортировки при работе с
методами репозитория.

`Sort.by("name")` -> `order by name asc`
`Sort.by("name", "price")` -> `order by name asc, price asc`
`Sort.by(Sort.Direction.DESC, "name")` -> `order by name desc`
`Sort.by(Sort.Direction.DESC, "name", "price")` -> `order by name desc, price desc`

`Order` - объект позволяющий определить правило сортировки для одного отдельно
взятого поля.

`Sort.by(Sort.Order.desc("price"), Sort.Order.asc("name"))` -> `order by price desc, name asc`

`Pageable` - объект передача которого в метод репозитория произведет разбиение
результата на страницы.

Java приложение может работать относительно контекстного пути сервера.
`localhost:8080` -> `/` (контекстный путь веб приложение).
`localhost:8080/spring_app` -> `/spring_app` (контекстный путь веб приложения).

У приложения могут быть ресурсы:
1) `/products` -> ресурс для получения всех товаров.
2) `/create_product` -> ресурс для создания нового товара.

Если контекстный путь будет `/` при адресе сервера `localhost:8080`, то
обращения к ресурсам будут следующими:
1) `localhost:8080/products`.
2) `localhost:8080/create_product`.

Если контекстный путь будет `/spring_app` при адресе сервера `localhost:8080`,
то обращения к ресурсам будут следующими:
1) `localhost:8080/spring_app/products`.
2) `localhost:8080/spring_app/create_product`.

Адрес ресурса складывается по формуле `контекстный путь` + `адрес ресурса в
приложении`.

`href="/products"` - ссылка на адрес приложения `/products`.

`th:href="@{/products}"` - ссылка на адрес приложения `/products` с учетом
возможного контекста веб приложения.













